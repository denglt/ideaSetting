<application>
  <component name="CoolRequestSetting">
    <option name="functionCode" value="package dev.coolrequest.function;&#13;&#10;&#13;&#10;import java.security.SecureRandom;&#13;&#10;import java.time.LocalDate;&#13;&#10;import java.time.LocalDateTime;&#13;&#10;import java.time.format.DateTimeFormatter;&#13;&#10;import java.util.UUID;&#13;&#10;&#13;&#10;/**&#13;&#10; * 1.You can write your own method here, but it must be an empty parameter&#13;&#10; * 2.Class name cannot be modified&#13;&#10; */&#13;&#10;public class CoolRequestFunction {&#13;&#10;    private static final String CHAR_LOWER = &quot;abcdefghijklmnopqrstuvwxyz&quot;;&#13;&#10;    private static final String CHAR_UPPER = CHAR_LOWER.toUpperCase();&#13;&#10;    private static final String NUMBER = &quot;0123456789&quot;;&#13;&#10;    private static final String SPECIAL_CHARS = &quot;!@#$%&amp;*()_+-=[]|,./?&gt;&lt;&quot;;&#13;&#10;    private static final String PASSWORD_ALLOW_BASE = CHAR_LOWER + CHAR_UPPER + NUMBER + SPECIAL_CHARS;&#13;&#10;    private static final String[] PROVINCES = {&#13;&#10;            &quot;北京&quot;, &quot;天津&quot;, &quot;上海&quot;, &quot;重庆&quot;, &quot;河北&quot;, &quot;山西&quot;, &quot;辽宁&quot;, &quot;吉林&quot;, &quot;黑龙江&quot;,&#13;&#10;            &quot;江苏&quot;, &quot;浙江&quot;, &quot;安徽&quot;, &quot;福建&quot;, &quot;江西&quot;, &quot;山东&quot;, &quot;河南&quot;, &quot;湖北&quot;, &quot;湖南&quot;,&#13;&#10;            &quot;广东&quot;, &quot;海南&quot;, &quot;四川&quot;, &quot;贵州&quot;, &quot;云南&quot;, &quot;陕西&quot;, &quot;甘肃&quot;, &quot;青海&quot;,&#13;&#10;            &quot;内蒙古&quot;, &quot;广西&quot;, &quot;西藏&quot;, &quot;宁夏&quot;, &quot;新疆&quot;&#13;&#10;    };&#13;&#10;    private static SecureRandom random = new SecureRandom();&#13;&#10;&#13;&#10;&#13;&#10;    public static String osName() {&#13;&#10;        return System.getProperty(&quot;os.name&quot;);&#13;&#10;    }&#13;&#10;&#13;&#10;    public String randomBoolean() {&#13;&#10;        return (random.nextInt(10) &amp; 2) == 0 ? &quot;true&quot; : &quot;false&quot;;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String randomHexColor() {&#13;&#10;        int red = random.nextInt(256);&#13;&#10;        int green = random.nextInt(256);&#13;&#10;        int blue = random.nextInt(256);&#13;&#10;        return String.format(&quot;#%02x%02x%02x&quot;, red, green, blue);&#13;&#10;    }&#13;&#10;&#13;&#10;    public String randomProvince() {&#13;&#10;        int randomIndex = random.nextInt(PROVINCES.length);&#13;&#10;        return PROVINCES[randomIndex];&#13;&#10;    }&#13;&#10;&#13;&#10;    public String randomPassword() {&#13;&#10;        StringBuilder sb = new StringBuilder(15);&#13;&#10;        for (int i = 0; i &lt; 15; i++) {&#13;&#10;            int randomIndex = random.nextInt(PASSWORD_ALLOW_BASE.length());&#13;&#10;            sb.append(PASSWORD_ALLOW_BASE.charAt(randomIndex));&#13;&#10;        }&#13;&#10;        return sb.toString();&#13;&#10;    }&#13;&#10;&#13;&#10;    public String randomChinesePhoneNumber() {&#13;&#10;        String[] prefixArray = {&quot;130&quot;, &quot;131&quot;, &quot;132&quot;, &quot;133&quot;, &quot;134&quot;, &quot;135&quot;, &quot;136&quot;, &quot;137&quot;, &quot;138&quot;, &quot;139&quot;,&#13;&#10;                &quot;145&quot;, &quot;147&quot;, &quot;149&quot;,&#13;&#10;                &quot;150&quot;, &quot;151&quot;, &quot;152&quot;, &quot;153&quot;, &quot;155&quot;, &quot;156&quot;, &quot;157&quot;, &quot;158&quot;, &quot;159&quot;,&#13;&#10;                &quot;166&quot;,&#13;&#10;                &quot;170&quot;, &quot;171&quot;, &quot;172&quot;, &quot;173&quot;, &quot;175&quot;, &quot;176&quot;, &quot;177&quot;, &quot;178&quot;,&#13;&#10;                &quot;180&quot;, &quot;181&quot;, &quot;182&quot;, &quot;183&quot;, &quot;184&quot;, &quot;185&quot;, &quot;186&quot;, &quot;187&quot;, &quot;188&quot;, &quot;189&quot;,&#13;&#10;                &quot;198&quot;, &quot;199&quot;};&#13;&#10;        String prefix = prefixArray[random.nextInt(prefixArray.length)];&#13;&#10;        StringBuilder sb = new StringBuilder(prefix);&#13;&#10;        for (int i = 0; i &lt; 8; i++) {&#13;&#10;            sb.append(random.nextInt(10));&#13;&#10;        }&#13;&#10;        return sb.toString();&#13;&#10;    }&#13;&#10;&#13;&#10;    public String randomGender() {&#13;&#10;        return random.nextBoolean() ? &quot;男&quot; : &quot;女&quot;;&#13;&#10;    }&#13;&#10;&#13;&#10;    public int randomAge() {&#13;&#10;        return random.nextInt(200) + 1;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String randomIPAddress() {&#13;&#10;        int octet1 = random.nextInt(256);&#13;&#10;        int octet2 = random.nextInt(256);&#13;&#10;        int octet3 = random.nextInt(256);&#13;&#10;        int octet4 = random.nextInt(256);&#13;&#10;        String ipAddress = octet1 + &quot;.&quot; + octet2 + &quot;.&quot; + octet3 + &quot;.&quot; + octet4;&#13;&#10;        return ipAddress;&#13;&#10;    }&#13;&#10;&#13;&#10;    public char randomChineseCharacter() {&#13;&#10;        char c = (char) (0x4E00 + random.nextInt(0x9FFF - 0x4E00 + 1));&#13;&#10;        return c;&#13;&#10;    }&#13;&#10;&#13;&#10;    public String guid() {&#13;&#10;        return UUID.randomUUID().toString();&#13;&#10;    }&#13;&#10;&#13;&#10;    public int year() {&#13;&#10;        return LocalDate.now().getYear();&#13;&#10;    }&#13;&#10;&#13;&#10;    public int month() {&#13;&#10;        return LocalDate.now().getMonthValue();&#13;&#10;    }&#13;&#10;&#13;&#10;    public int day() {&#13;&#10;        return LocalDate.now().getDayOfMonth();&#13;&#10;    }&#13;&#10;&#13;&#10;    public int hour() {&#13;&#10;        return LocalDateTime.now().getHour();&#13;&#10;    }&#13;&#10;&#13;&#10;    public int minute() {&#13;&#10;        return LocalDateTime.now().getMinute();&#13;&#10;    }&#13;&#10;&#13;&#10;    public int second() {&#13;&#10;        return LocalDateTime.now().getSecond();&#13;&#10;    }&#13;&#10;&#13;&#10;    public String dateTime() {&#13;&#10;        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd HH:mm:ss&quot;));&#13;&#10;    }&#13;&#10;&#13;&#10;    public String date() {&#13;&#10;        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd&quot;));&#13;&#10;    }&#13;&#10;&#13;&#10;    public String time() {&#13;&#10;        return LocalDateTime.now().format(DateTimeFormatter.ofPattern(&quot;HH:mm:ss&quot;));&#13;&#10;    }&#13;&#10;}" />
    <option name="customURLConvertFunction" value="package dev.coolrequest.script;&#13;&#10;&#13;&#10;import com.cool.request.script.API;&#13;&#10;import com.cool.request.script.IEnv;&#13;&#10;import com.cool.request.script.Module;&#13;&#10;&#13;&#10;import java.util.regex.Matcher;&#13;&#10;import java.util.regex.Pattern;&#13;&#10;&#13;&#10;public class CoolRequestURLPostProcessorScript {&#13;&#10;    private static final char SLASH = '/';&#13;&#10;    private static final Pattern TRIM_PATTERN = Pattern.compile(&quot;^/*(.*?)/*$&quot;);&#13;&#10;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * en.This method is used to customize URLs, and whenever you double-click an API, the urlPostProcessor method will be called&#13;&#10;     * cn.这个方法用于自定义URL，每当双击一个API时，urlPostProcessor方法会被调用&#13;&#10;     *&#13;&#10;     * @param originURL CoolRequest will automatically generate a URL based on the environment, and this object represents the original URL&#13;&#10;     *                  CoolRequest会根据环境自动生成url，此对象表示原始url&#13;&#10;     * @param apiModule The module object where the API is located can read the properties defined in springboot using the `readProperty` method&#13;&#10;     *                  API所在模块对象，可根据readProperty方法读取springboot中定义得属性&#13;&#10;     * @param api       API object that can retrieve port, path, and context path&#13;&#10;     *                  API对象，可获取port、path、context-path&#13;&#10;     * @param iEnv      Environmental objects&#13;&#10;     *                  环境对象&#13;&#10;     * @return If null is returned or any exception occurs, use originURL; if not empty, use this return value,&#13;&#10;     *         Please be aware of the NullPointerException exception during the writing process&#13;&#10;     *&#13;&#10;     *         如果返回null或者出现任何异常，则使用originURL，如果不为空，则使用此返回值,请在编写过程中，注意NullPointerException异常&#13;&#10;     */&#13;&#10;    public String urlPostProcessor(String originURL, Module apiModule, API api, IEnv iEnv) {&#13;&#10;        //return collectPath(&quot;http://localhost:7070&quot;,apiModule.getName(), api.getPath())&#13;&#10;        return null;&#13;&#10;    }&#13;&#10;&#13;&#10;&#13;&#10;    /**&#13;&#10;     * This method allows users to merge URLs&#13;&#10;     * 此方法用于合并url&#13;&#10;     *&#13;&#10;     * collectPath(&quot;http://localhost:7070&quot;,&quot;src&quot;,&quot;hello&quot;) ==&gt; http://localhost:7070/src/hello&#13;&#10;     */&#13;&#10;    private static String collectPath(String... pathParts) {&#13;&#10;        final StringBuilder sb = new StringBuilder();&#13;&#10;        for (String item : pathParts) {&#13;&#10;            if (isBlank(item)) {&#13;&#10;                continue;&#13;&#10;            }&#13;&#10;            if (item.startsWith(&quot;http://&quot;) || item.startsWith(&quot;https://&quot;)) {&#13;&#10;                sb.append(trimPath(item));&#13;&#10;            } else {&#13;&#10;                final String path = trimPath(item);&#13;&#10;                if (isNotBlank(path)) {&#13;&#10;                    sb.append(SLASH).append(path);&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;        return sb.length() &gt; 0 ? sb.toString() : String.valueOf(SLASH);&#13;&#10;    }&#13;&#10;&#13;&#10;    public static int length(final CharSequence cs) {&#13;&#10;        return cs == null ? 0 : cs.length();&#13;&#10;    }&#13;&#10;&#13;&#10;    public static boolean isBlank(final CharSequence cs) {&#13;&#10;        final int strLen = length(cs);&#13;&#10;        if (strLen == 0) {&#13;&#10;            return true;&#13;&#10;        }&#13;&#10;        for (int i = 0; i &lt; strLen; i++) {&#13;&#10;            if (!Character.isWhitespace(cs.charAt(i))) {&#13;&#10;                return false;&#13;&#10;            }&#13;&#10;        }&#13;&#10;        return true;&#13;&#10;    }&#13;&#10;&#13;&#10;    private static String trimPath(String value) {&#13;&#10;        final Matcher matcher = TRIM_PATTERN.matcher(value);&#13;&#10;        return matcher.find() &amp;&amp; isNotBlank(matcher.group(1)) ? matcher.group(1) : null;&#13;&#10;    }&#13;&#10;&#13;&#10;    public static boolean isNotBlank(CharSequence cs) {&#13;&#10;        return !isBlank(cs);&#13;&#10;    }&#13;&#10;&#13;&#10;}" />
  </component>
</application>